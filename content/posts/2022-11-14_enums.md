+++
title = "Rust enums"
draft = true
+++

Draft notes:

* enum size
* alignment
* discriminant
* discriminant size

Note: alignment is platform specific and should not be assumed to always be the
same across all platforms.

## Size

The size of an enum is the size of its largest variant + the discriminant (unless the discriminant can been optimised away).

Given the following enum:
```rust
enum TheEnum {
    A,
    B(u8),
    C(u64),
}
```

The `C` variant is the largest one, so in this case the size is eight bytes (the size of a `u64`).
The discriminant is a `usize` by default. On a 64 bit architecture that's the
same size as a `u64` / `i64`, making the discriminant eight bytes as well.

This means a total size of 16 bytes.

It makes sense that an enum is always the size of its largest variant (+ discriminant), otherwise
it would be difficult to store enums in a vector (how would you find the fifth
value without looking at every value before it?).

Note: the discriminant can be larger than the alignment, e.g by using `#[repr(u128)]`
(this is nightly only right now).

* To enable `repr(u128)` add `#![feature(repr128)]`.

## Bytes

To see the byte representation of an enum it can be transmuted into a byte
array:

```rust
const SIZE: usize = std::mem::size_of::<TheEnum>();
let bytes = unsafe {
    std::mem::transmute::<_, [u8; SIZE]>(TheEnum::SomeVariant)
};
```

Note: if the discriminant size is different than the padding, then any data after
the size but inside the alignment is "garbage data".  

* If an enum only has one variant, there is no additional data for the discriminant. I.e all the bytes
  represent that variant

## Rust does some cool tricks in regards to layout:

Looking at an enum like the one below we can see that it has two variants: A and B.
`A` contains a `Vec<u8>`, and the size of a vector is 24 bytes (on a 64 bit system), 
since its composed of a pointer (8 bytes), capacity (8 bytes) and size (8 bytes).

```rust
enum Choice {
    A(Vec<u8>),
    B,
}
```

We can easily imagine that the size of the enum is then 32 bytes: 28 bytes for
the vector, and one byte for the discriminant. 
This is however not the case.
Because the first eight bytes in the vector is a pointer, and that pointer can
never be zero, the compiler can reserve `0` for `Choice::B`.
This means when we are looking at the bytes for the enum, if the first byte is
not zero it means the variant is `A`, anything else means it's `B`.

This is called Null Pointer Optimisation, because the pointer in the vector can
never be zero.

## Repr and size

If `#[repr]` is set, then the discriminant might not be optimised away.
A field-less enum (an enum where the variants have no associated data) with just
a handful of variants can be represented as a single byte:

```rust
enum Choice {
    A,
    B,
    C
}
```
The size of the enum would be one byte.

However if `#[repr(u16)]` is set:
```rust
#[repr(u16)]
enum Choice {
    A,
    B,
    C
}
```
The size of the enum would be two bytes.
